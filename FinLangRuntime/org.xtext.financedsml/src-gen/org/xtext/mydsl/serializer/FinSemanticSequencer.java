/*
 * generated by Xtext 2.33.0
 */
package org.xtext.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.mydsl.fin.Bond;
import org.xtext.mydsl.fin.Buy;
import org.xtext.mydsl.fin.Cash;
import org.xtext.mydsl.fin.Delete;
import org.xtext.mydsl.fin.Deposit;
import org.xtext.mydsl.fin.FinPackage;
import org.xtext.mydsl.fin.Model;
import org.xtext.mydsl.fin.Option;
import org.xtext.mydsl.fin.Portfolio;
import org.xtext.mydsl.fin.Sell;
import org.xtext.mydsl.fin.View;
import org.xtext.mydsl.fin.Withdrawal;
import org.xtext.mydsl.services.FinGrammarAccess;

@SuppressWarnings("all")
public class FinSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FinGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FinPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FinPackage.BOND:
				sequence_Bond(context, (Bond) semanticObject); 
				return; 
			case FinPackage.BUY:
				sequence_Buy(context, (Buy) semanticObject); 
				return; 
			case FinPackage.CASH:
				sequence_Cash(context, (Cash) semanticObject); 
				return; 
			case FinPackage.DELETE:
				sequence_Delete(context, (Delete) semanticObject); 
				return; 
			case FinPackage.DEPOSIT:
				sequence_Deposit(context, (Deposit) semanticObject); 
				return; 
			case FinPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case FinPackage.OPTION:
				sequence_Option(context, (Option) semanticObject); 
				return; 
			case FinPackage.PORTFOLIO:
				sequence_Portfolio(context, (Portfolio) semanticObject); 
				return; 
			case FinPackage.SELL:
				sequence_Sell(context, (Sell) semanticObject); 
				return; 
			case FinPackage.VIEW:
				sequence_View(context, (View) semanticObject); 
				return; 
			case FinPackage.WITHDRAWAL:
				sequence_Withdrawal(context, (Withdrawal) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Asset returns Bond
	 *     Bond returns Bond
	 *
	 * Constraint:
	 *     (name=ID faceValue=FLOAT couponRate=FLOAT maturity=INT yieldRate=FLOAT)
	 * </pre>
	 */
	protected void sequence_Bond(ISerializationContext context, Bond semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.BOND__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.BOND__NAME));
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.BOND__FACE_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.BOND__FACE_VALUE));
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.BOND__COUPON_RATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.BOND__COUPON_RATE));
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.BOND__MATURITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.BOND__MATURITY));
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.BOND__YIELD_RATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.BOND__YIELD_RATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBondAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getBondAccess().getFaceValueFLOATParserRuleCall_4_0(), semanticObject.getFaceValue());
		feeder.accept(grammarAccess.getBondAccess().getCouponRateFLOATParserRuleCall_6_0(), semanticObject.getCouponRate());
		feeder.accept(grammarAccess.getBondAccess().getMaturityINTTerminalRuleCall_8_0(), semanticObject.getMaturity());
		feeder.accept(grammarAccess.getBondAccess().getYieldRateFLOATParserRuleCall_10_0(), semanticObject.getYieldRate());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Buy
	 *     Transaction returns Buy
	 *     Buy returns Buy
	 *
	 * Constraint:
	 *     (portfolio=[Portfolio|ID] (bond=Bond | option=Option))
	 * </pre>
	 */
	protected void sequence_Buy(ISerializationContext context, Buy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Asset returns Cash
	 *     Cash returns Cash
	 *
	 * Constraint:
	 *     amount=FLOAT
	 * </pre>
	 */
	protected void sequence_Cash(ISerializationContext context, Cash semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.CASH__AMOUNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.CASH__AMOUNT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCashAccess().getAmountFLOATParserRuleCall_3_0(), semanticObject.getAmount());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Delete
	 *     Action returns Delete
	 *     Delete returns Delete
	 *
	 * Constraint:
	 *     portfolio=[Portfolio|ID]
	 * </pre>
	 */
	protected void sequence_Delete(ISerializationContext context, Delete semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.ACTION__PORTFOLIO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.ACTION__PORTFOLIO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeleteAccess().getPortfolioPortfolioIDTerminalRuleCall_3_0_1(), semanticObject.eGet(FinPackage.Literals.ACTION__PORTFOLIO, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Deposit
	 *     Transaction returns Deposit
	 *     Deposit returns Deposit
	 *
	 * Constraint:
	 *     (portfolio=[Portfolio|ID] amount=FLOAT)
	 * </pre>
	 */
	protected void sequence_Deposit(ISerializationContext context, Deposit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.TRANSACTION__PORTFOLIO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.TRANSACTION__PORTFOLIO));
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.DEPOSIT__AMOUNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.DEPOSIT__AMOUNT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDepositAccess().getPortfolioPortfolioIDTerminalRuleCall_3_0_1(), semanticObject.eGet(FinPackage.Literals.TRANSACTION__PORTFOLIO, false));
		feeder.accept(grammarAccess.getDepositAccess().getAmountFLOATParserRuleCall_5_0(), semanticObject.getAmount());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     element+=Element+
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Asset returns Option
	 *     Option returns Option
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         type=OptionType 
	 *         underlyingPrice=FLOAT 
	 *         strikePrice=FLOAT 
	 *         timeToExpiration=FLOAT 
	 *         riskFreeRate=FLOAT 
	 *         volatility=FLOAT 
	 *         dividendYield=FLOAT
	 *     )
	 * </pre>
	 */
	protected void sequence_Option(ISerializationContext context, Option semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.OPTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.OPTION__NAME));
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.OPTION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.OPTION__TYPE));
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.OPTION__UNDERLYING_PRICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.OPTION__UNDERLYING_PRICE));
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.OPTION__STRIKE_PRICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.OPTION__STRIKE_PRICE));
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.OPTION__TIME_TO_EXPIRATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.OPTION__TIME_TO_EXPIRATION));
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.OPTION__RISK_FREE_RATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.OPTION__RISK_FREE_RATE));
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.OPTION__VOLATILITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.OPTION__VOLATILITY));
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.OPTION__DIVIDEND_YIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.OPTION__DIVIDEND_YIELD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOptionAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOptionAccess().getTypeOptionTypeEnumRuleCall_4_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getOptionAccess().getUnderlyingPriceFLOATParserRuleCall_6_0(), semanticObject.getUnderlyingPrice());
		feeder.accept(grammarAccess.getOptionAccess().getStrikePriceFLOATParserRuleCall_8_0(), semanticObject.getStrikePrice());
		feeder.accept(grammarAccess.getOptionAccess().getTimeToExpirationFLOATParserRuleCall_10_0(), semanticObject.getTimeToExpiration());
		feeder.accept(grammarAccess.getOptionAccess().getRiskFreeRateFLOATParserRuleCall_12_0(), semanticObject.getRiskFreeRate());
		feeder.accept(grammarAccess.getOptionAccess().getVolatilityFLOATParserRuleCall_14_0(), semanticObject.getVolatility());
		feeder.accept(grammarAccess.getOptionAccess().getDividendYieldFLOATParserRuleCall_16_0(), semanticObject.getDividendYield());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Portfolio
	 *     Portfolio returns Portfolio
	 *
	 * Constraint:
	 *     (name=ID asset+=Asset+)
	 * </pre>
	 */
	protected void sequence_Portfolio(ISerializationContext context, Portfolio semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Sell
	 *     Transaction returns Sell
	 *     Sell returns Sell
	 *
	 * Constraint:
	 *     ((portfolio=[Portfolio|ID] bond=[Bond|ID]) | (option=[Option|ID] amount=FLOAT))
	 * </pre>
	 */
	protected void sequence_Sell(ISerializationContext context, Sell semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns View
	 *     Action returns View
	 *     View returns View
	 *
	 * Constraint:
	 *     (portfolio=[Portfolio|ID] range=INT unit=TimeUnit)
	 * </pre>
	 */
	protected void sequence_View(ISerializationContext context, View semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.ACTION__PORTFOLIO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.ACTION__PORTFOLIO));
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.VIEW__RANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.VIEW__RANGE));
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.VIEW__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.VIEW__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getViewAccess().getPortfolioPortfolioIDTerminalRuleCall_3_0_1(), semanticObject.eGet(FinPackage.Literals.ACTION__PORTFOLIO, false));
		feeder.accept(grammarAccess.getViewAccess().getRangeINTTerminalRuleCall_5_0(), semanticObject.getRange());
		feeder.accept(grammarAccess.getViewAccess().getUnitTimeUnitEnumRuleCall_6_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Withdrawal
	 *     Transaction returns Withdrawal
	 *     Withdrawal returns Withdrawal
	 *
	 * Constraint:
	 *     (portfolio=[Portfolio|ID] amount=FLOAT)
	 * </pre>
	 */
	protected void sequence_Withdrawal(ISerializationContext context, Withdrawal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.TRANSACTION__PORTFOLIO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.TRANSACTION__PORTFOLIO));
			if (transientValues.isValueTransient(semanticObject, FinPackage.Literals.WITHDRAWAL__AMOUNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FinPackage.Literals.WITHDRAWAL__AMOUNT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWithdrawalAccess().getPortfolioPortfolioIDTerminalRuleCall_3_0_1(), semanticObject.eGet(FinPackage.Literals.TRANSACTION__PORTFOLIO, false));
		feeder.accept(grammarAccess.getWithdrawalAccess().getAmountFLOATParserRuleCall_5_0(), semanticObject.getAmount());
		feeder.finish();
	}
	
	
}
