/*
 * generated by Xtext 2.33.0
 */
package org.xtext.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.mydsl.fin.Bond
import org.xtext.mydsl.fin.Option

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class FinGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		// Generate utility classes for Bond and Option calculations
    	generateBond(fsa)
    	generateOption(fsa)
    
    	// Generate the main class that uses the utility classes
    	generateMain(resource, fsa)
	}
	
	def protected void generateBond(IFileSystemAccess2 fsa) {
	   val content = '''
		    public class BondCalculator {
		        public static double calculatePrice(double faceValue, double couponRate, int maturity, double yieldRate) {
		            // Simplified bond valuation formula
		            return faceValue / Math.pow(1 + yieldRate, maturity);
		        }
		    }
		'''
		fsa.generateFile("BondCalculator.java", content)
	   
	}
	
	// TODO: create static class with static methods to view assets
	
	
	def protected void generateOption(IFileSystemAccess2 fsa) {
		val content = '''
		    import org.apache.commons.math3.distribution.NormalDistribution;
		
		    public class OptionCalculator {
		        public static double calculateBlackScholes(double S, double K, double T, double r, double sigma) {
		            double d1 = (Math.log(S / K) + (r + sigma * sigma / 2) * T) / (sigma * Math.sqrt(T));
		            double d2 = d1 - sigma * Math.sqrt(T);
		            
		            NormalDistribution nd = new NormalDistribution();
		            return S * nd.cumulativeProbability(d1) - K * Math.exp(-r * T) * nd.cumulativeProbability(d2);
		        }
		    }
		'''
		fsa.generateFile("OptionCalculator.java", content)
	}
	
	def protected void generateMain(Resource resource, IFileSystemAccess2 fsa) {
	    val bonds = resource.allContents.toIterable.filter(Bond)
	    val options = resource.allContents.toIterable.filter(Option)
	
	    val content = '''
	        import java.io.PrintWriter;
	        import java.io.File;
	
	        public class FinancialCalculatorMain {
	            public static void main(String[] args) {
	                try (PrintWriter writer = new PrintWriter(new File("financial_results.txt"))) {
	                    // Calculate and write bond values
	                    «FOR bond : bonds»
	                    double bondPrice = BondCalculator.calculatePrice(«bond.faceValue», «bond.couponRate», «bond.maturity», «bond.yieldRate»);
	                    writer.println("Bond Price: " + bondPrice);
	                    «ENDFOR»
	
	                    // Calculate and write option values
	                    «FOR option : options»
	                    double optionPrice = OptionCalculator.calculateBlackScholes(«option.underlyingPrice», «option.strikePrice», «option.timeToExpiration», «option.riskFreeRate», «option.volatility»);
	                    writer.println("Option Price: " + optionPrice);
	                    «ENDFOR»
	                } catch (Exception e) {
	                    e.printStackTrace();
	                }
	            }
	        }
	    '''
	    fsa.generateFile("FinancialCalculatorMain.java", content)
	}


	
		
}
